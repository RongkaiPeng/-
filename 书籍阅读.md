为什么数据库索引中需要用==B树or B+树？==

> 因为数据库存储的数据和索引都放在磁盘，他们以页为单位管理磁盘，AVL或红黑树搜索效率尽管高，但是同样的数据项，他们的树要比B B+树高，高意味着平均来说访问更多的节点，即磁盘IO次数，表面上B、B+没有二叉搜索树效率高，但是实际上因为树高度低，减少IO次数，所以速度快

==AVL树==：左右子树高度差不超过1

==CAS==叫做CompareAndSwap，比较并交换，主要是通过处理器的指令来保证操作的==原子性==（操作不可在细分），它包含三个操作数：

1. 变量内存地址，V表示
2. 旧的预期值，A表示
3. 准备设置的新值，B表示

当执行CAS指令时，只有当V等于A时，才会用B去更新V的值，否则就不会执行更新操作。

cpu在计算的时候的**数据读取顺序**优先级 是：寄存器－高速缓存－内存。

所有线程共享==主内存==，每个线程有自己的==工作内存==，主内存可以认为就是物理内存，Java内存模型中实际就是虚拟机内存的一部分。而工作内存就是CPU缓存，他有可能是寄存器也有可能是L1\L2\L3缓存，都是有可能的。

==缓存一致性==:在多核CPU中，每个核拥有自己的缓存。可能会出现两个核的缓存里都拥有相同数据的副本，在两个核独自进行修改的情况下导致数据的不一致，问题的根源在于多个缓存和他们的写操作

==缓存一致性协议==：属于窥探协议（snooping），各个核能够时刻监控自己和其他核的状态，从而统一管理协调。窥探的思想是：CPU的各个缓存是独立的，但是内存却是共享的，所有缓存的数据最终都通过总线写入同一个内存，因此CPU各个核都能“看见”总线，即各个缓存不仅在进行内存数据交换的时候访问总线，还可以时刻“窥探”总线，监控其他缓存在干什么。因此当一个缓存在往内存中写数据时，其他缓存也都能“窥探”到，从而按照一致性协议保证缓存间的同步。

==内存可见性==：工作内存和主内存的数据存取造成的问题

==原子性：==原子性就是指该操作是不可再分的。不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作。简而言之，在整个操作过程中不会被线程调度器中断的操作，都可认为是原子性。比如 a = 1；

==非原子性==：也就是整个过程中会出现线程调度器中断操作的现象

类似"a ++"这样的操作不具有原子性，因为它可能要经过以下两个步骤：

（1）取出 a 的值

（2）计算 a+1

如果有两个线程t1，t2在进行这样的操作。t1在第一步做完之后还没来得及加1操作就被线程调度器中断了，于是t2开始执行，t2执行完毕后t1开始执行第二步(此时t1中a的值可能还是旧值，不是一定的，只有线程t2中a的值没有及时更新到t1中才会出现)。这个时候就出现了错误，t2的操作相当于被忽略了

==new一个对象的过程==：

当虚拟机遇见new关键字时候，实现判断当前类是否已经加载，如果类没有加载，首先执行类的加载机制，加载完成后再为对象分配空间、初始化等。

1. 首先校验当前类是否被加载，如果没有加载，执行类加载机制
2. 加载：就是从字节码加载成二进制流的过程
3. 验证：当然加载完成之后，当然需要校验Class文件是否符合虚拟机规范，跟我们接口请求一样，第一件事情当然是先做个参数校验了
4. 准备：为静态变量、常量赋默认值
5. 解析：把常量池中符号引用(以符号描述引用的目标)替换为直接引用(指向目标的指针或者句柄等)的过程
6. 初始化：执行static代码块(cinit)进行初始化，如果存在父类，先对父类进行初始化

当类加载完成之后，紧接着就是对象分配内存空间和初始化的过程

1. 首先为对象分配合适大小的内存空间
2. 接着为实例变量赋默认值
3. 设置对象的头信息，对象hash码、GC分代年龄、元数据信息等
4. 执行构造函数(init)初始化

### ==OOM的场景和解决方法==

OutOfMemory异常：

1. 堆内存溢出

   堆内存用来存储对象实例，只要不停的创建对象，并且保证GC Roots和对象之间有可达路径避免垃圾回收，那么在对象数量超过最大堆的大小限制后很快就能出现这个异常。

   一般的排查方式可以通过设置-XX: +HeapDumpOnOutOfMemoryError在发生异常时dump出当前的内存转储快照来分析，此外IDEA2018版本之后内置了分析工具，包括Flame Graph(火焰图)和Call Tree(调用树)功能

2. 方法区（运行时常量池）和元空间溢出

   方法区和堆一样，是线程共享的区域，包含class文件信息、运行时常量池、常量池，**运行时常量池**和**常量池**的主要区别是具备动态性，也就是不一定非要是在Class文件中的常量池中的内容才能进入运行时常量池，运行期间也可以可以将新的常量放入池中，比如String的intern()方法。

   1.8之后取消了永久代的概念，转为元空间(Metaspace)

   ```java
   private static String str = "test";
     public static void main(String[] args) {
       List<String> list = new ArrayList<>();
       while (true){
         String str2 = str + str;
         str = str2;
         list.add(str.intern());
       }
   }
   ```

3. 直接内存溢出

   直接内存并不是虚拟机运行时数据区域的一部分，并且不受堆内存的限制，但是受到机器内存大小的限制。常见的比如在NIO中可以使用native函数直接分配堆外内存就容易导致OOM的问题。直接内存大小可以通过-XX:MaxDirectMemorySize指定，**如果不指定，则默认与Java 堆最大值-Xmx一样。**

   由直接内存导致的内存溢出，一个明显的特征是在Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。

4. 栈内存移除

   栈是线程私有，它的生命周期和线程相同。每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息，方法调用的过程就是栈帧入栈和出栈的过程。

   在java虚拟机规范中，对虚拟机栈定义了两种异常：

   1. 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常
   2. 如果虚拟机栈可以动态扩展，并且扩展时无法申请到足够的内存，抛出OutOfMemoryError异常

------



### ==Hashmap原理==

HashMap主要由数组和链表组成，他不是线程安全的。核心的点就是put插入数据的过程，get查询数据以及扩容的方式。JDK1.7和1.8的主要区别在于头插和尾插方式的修改，头插容易导致HashMap链表死循环，并且1.8之后加入红黑树对性能有提升。

> 线程不安全是因为两个线程，有一个在存入，另一个在扩容、复制的时候，对数组的插入不稳定，会导致冲突

**put插入数据流程**

往map插入元素的时候首先通过对key hash然后与数组长度-1进行与运算((n-1)&hash)，都是2的次幂所以等同于取模，但是位运算的效率更高。找到数组中的位置之后，如果数组中没有元素直接存入，反之则判断key是否相同，key相同就覆盖，否则就会插入到链表的尾部，如果链表的长度超过8，则会转换成==红黑树==，最后判断数组长度是否超过默认的长度*负载因子也就是12，超过则进行扩容。

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUljPgPC9h7FmEyOSbttvPehhYJqIVUVqkQmiaXVoachgswvKcUfQ5AdgbJpYngXOvicVTDub1KxYMsw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

**get查询数据**

查询数据相对来说就比较简单了，首先计算出hash值，然后去数组查询，是红黑树就去红黑树查，链表就遍历链表查询就可以了。

**resize扩容过程**

扩容的过程就是对key重新计算hash，然后把数据拷贝到新的数组。

# 深入理解计算机系统

操作系统有两个基本作用：防止硬件被失控的应用程序滥用
					  向应用程序提供简单的机制来控制低级硬件设备
进程是操作系统对正在运行程序的抽象，进程是资源分配的 基本单位，
进程由多个称为线程的执行，线程是独立调度的基本单位，是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。





# 深入理解java虚拟机

## 3.垃圾收集器与内存分配策略

程序计数器、本地方法栈、虚拟机栈为线程私有，随着线程创建销毁，不用过多考虑如何回收，方法或线程结束时，内存跟随着回收。

但堆和方法区不同，需要考虑如何进行垃圾回收

判断对象如何存活？

- （教科书中）（java中并不是这样）对象中添引用计数器，引用时加一，引用失效，减一

  但如果两个对象相互循环引用，则计数器都不为0，无法被回收

- ==可达性分析算法==：通过GC root作为起始节点集，根据引用关系向下搜索，搜索过程称为引用链，如果某个对象到GC root没有任何链相连，则不可达，成为可回收对象

  可作为==GC root==的对象：

  - 虚拟机栈（本地变量表中引用对象）
  - 方法区中静态属性和常量引用的对象
  - native方法引用的对象
  - 同步锁持有的对象

  如果对象不可达，也并非一定会死掉，==真正的死亡会经历两次过程==：

  1.如果可达性分析没有发现与GC root相连，则被==第一次标记==，而后进行筛选，筛选条件为该对象是否有必要执行finalize()方法，

  - 如果对象没有覆盖方法或者方法已经被执行，则都视为没有必要执行。
  - 如果被确定为执行`finalize()`方法，则会放入一个F-Queue队列中，并稍后由虚拟机自动建立的一条Finalize线程去执行他们的finalize()方法，finalize()方法时对象逃脱死亡的最后一次机会，

  2.稍后收集器会堆F-Queue中的对象进行==第二次小规模标记==，如果对象在`finalize()`中成功拯救自己（与引用链上的对象关联，比如把自己this关键字赋值给某个类变量或者对象的成员变量），第二次标记时会被移除即将标记的集合，如果还没有逃脱，就会被回收 

  类如何被判定回收？

  1. 类的所有实例都被回收，java堆中不存在任何该类或者派生子类的实例
  2. 加载类的类加载器已经被回收，
  3. 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

#### 3.2垃圾收集算法

##### 分代理论

java堆常被分为新生代和老年代，

新生代中的对象存在时间短、把他们放在一起以较低的代价回收大量的空间，

剩下的难以回收的放在一起，用较低的频率回收这个区域，老年代

新生代中回收后存活的对象放入老年代

如果存在跨代引用（新生代中的东西被年老代引用）（相互引用的两个对象，应当同时存在或者同时消亡），则在新生代中建立全局数据结构——记忆集，把老年代划分为若干小块，标记出年老代中那一块内存会存在跨代引用，当新生代中垃圾收集之后，只有包含了跨代引用的小块内存的对象才会被加入GC root扫描（比起扫描整个老年代划算的多），而后跨代引用的东西加入老年代

##### 标记-清除算法（基本方法）

标记出所有要回收的，然后清除。or 标记存活的对象，然后清除剩余的

缺点：执行效率不稳定，java堆包含大量对象，大部分需要被回收；标记清除后产生大量不连续的内存碎片，导致以后需要分配较大对象时没有连续空间而再次触发垃圾收集动作

##### 标记-复制算法（针对新生代）

新生代中98%熬不过第一轮收集，因此在新生代中建立一个Eden，两个Survivor区域，每次分配内存只是用一块Eden和Survivor，大小比为8：1。垃圾收集后，将Eden和Survivor中存活的复制到另一个Survivor中，然后直接清空Eden和Survivor。

> 但如果存活的超过了Survivor，则有逃生门安全设计，无法容纳时，需要依赖其他内存区域（老年代）进行分配担保

##### 标记-整理算法（老年代）

类似于标记清除算法，只是在标记存活时，将存活的移到内存的一端，而后清理边界外的区域，

##### 和稀泥式回收

先用标记清除，而后碎片化足够严重时使用标记整理算法



class Solution {
    public String predictPartyVictory(String senate) {
        int n = senate.length();
        Queue<Integer> radiant = new LinkedList<Integer>();
        Queue<Integer> dire = new LinkedList<Integer>();
        for (int i = 0; i < n; ++i) {
            if (senate.charAt(i) == 'R') {
                radiant.offer(i);
            } else {
                dire.offer(i);
            }
        }
        while (!radiant.isEmpty() && !dire.isEmpty()) {
            int radiantIndex = radiant.poll(), direIndex = dire.poll();
            if (radiantIndex < direIndex) {
                radiant.offer(radiantIndex + n);
            } else {
                dire.offer(direIndex + n);
            }
        }
        return !radiant.isEmpty() ? "Radiant" : "Dire";
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/dota2-senate/solution/dota2-can-yi-yuan-by-leetcode-solution-jb7l/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# labuladong的算法小抄

> https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/xue-xi-shu-ju-jie-gou-he-suan-fa-de-gao-xiao-fang-fa

## 零

### 1.数据结构的存储方式

**数据的存数组储方式只有两种，数组和链表**

> 其他的诸如散列表、栈、堆等都是对数组和链表的特殊操作

优缺点：

**数组**由于是紧凑连续存储,可以==随机访问==，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。

**链表**因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的==扩容==问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。

### 2.数据结构的基本操作

基本操作就是增删查改

对于数组来说，迭代即可

但对于链表来说，可以迭代和递归

```java
//单链表
class ListNode{
	int val;
    ListNode next;
}

void traverse(ListNode head){
    for(ListNode p = head; p != null; p = p.next){
        //迭代访问p.val 
    }
}

void traverse(ListNode head){
    //递归访问head.val
    traverse(head.next)
}
```

二叉树遍历框架，典型的非线性递归遍历结构

```java
//基本的二叉树结点
class TreeNode{ 
    int val;
    TreeNode left,right;
}

void traverse(TreeNode root){
    traverse(TreeNode.left);
    traverse(TreeNode.right);

}
```

 