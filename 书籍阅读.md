为什么数据库索引中需要用==B树or B+树？==

> 因为数据库存储的数据和索引都放在磁盘，他们以页为单位管理磁盘，AVL或红黑树搜索效率尽管高，但是同样的数据项，他们的树要比B B+树高，高意味着平均来说访问更多的节点，即磁盘IO次数，表面上B、B+没有二叉搜索树效率高，但是实际上因为树高度低，减少IO次数，所以速度快

==AVL树==：左右子树高度差不超过1

==CAS==叫做CompareAndSwap，比较并交换，主要是通过处理器的指令来保证操作的==原子性==（操作不可在细分），它包含三个操作数：

1. 变量内存地址，V表示
2. 旧的预期值，A表示
3. 准备设置的新值，B表示

当执行CAS指令时，只有当V等于A时，才会用B去更新V的值，否则就不会执行更新操作。

cpu在计算的时候的**数据读取顺序**优先级 是：寄存器－高速缓存－内存。

所有线程共享==主内存==，每个线程有自己的==工作内存==，主内存可以认为就是物理内存，Java内存模型中实际就是虚拟机内存的一部分。而工作内存就是CPU缓存，他有可能是寄存器也有可能是L1\L2\L3缓存，都是有可能的。

==缓存一致性==:在多核CPU中，每个核拥有自己的缓存。可能会出现两个核的缓存里都拥有相同数据的副本，在两个核独自进行修改的情况下导致数据的不一致，问题的根源在于多个缓存和他们的写操作

==缓存一致性协议==：属于窥探协议（snooping），各个核能够时刻监控自己和其他核的状态，从而统一管理协调。窥探的思想是：CPU的各个缓存是独立的，但是内存却是共享的，所有缓存的数据最终都通过总线写入同一个内存，因此CPU各个核都能“看见”总线，即各个缓存不仅在进行内存数据交换的时候访问总线，还可以时刻“窥探”总线，监控其他缓存在干什么。因此当一个缓存在往内存中写数据时，其他缓存也都能“窥探”到，从而按照一致性协议保证缓存间的同步。

==内存可见性==：工作内存和主内存的数据存取造成的问题

==原子性：==原子性就是指该操作是不可再分的。不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作。简而言之，在整个操作过程中不会被线程调度器中断的操作，都可认为是原子性。比如 a = 1；

==非原子性==：也就是整个过程中会出现线程调度器中断操作的现象

类似"a ++"这样的操作不具有原子性，因为它可能要经过以下两个步骤：

（1）取出 a 的值

（2）计算 a+1

如果有两个线程t1，t2在进行这样的操作。t1在第一步做完之后还没来得及加1操作就被线程调度器中断了，于是t2开始执行，t2执行完毕后t1开始执行第二步(此时t1中a的值可能还是旧值，不是一定的，只有线程t2中a的值没有及时更新到t1中才会出现)。这个时候就出现了错误，t2的操作相当于被忽略了

==new一个对象的过程==：

当虚拟机遇见new关键字时候，实现判断当前类是否已经加载，如果类没有加载，首先执行类的加载机制，加载完成后再为对象分配空间、初始化等。

1. 首先校验当前类是否被加载，如果没有加载，执行类加载机制
2. 加载：就是从字节码加载成二进制流的过程
3. 验证：当然加载完成之后，当然需要校验Class文件是否符合虚拟机规范，跟我们接口请求一样，第一件事情当然是先做个参数校验了
4. 准备：为静态变量、常量赋默认值
5. 解析：把常量池中符号引用(以符号描述引用的目标)替换为直接引用(指向目标的指针或者句柄等)的过程
6. 初始化：执行static代码块(cinit)进行初始化，如果存在父类，先对父类进行初始化

当类加载完成之后，紧接着就是对象分配内存空间和初始化的过程

1. 首先为对象分配合适大小的内存空间
2. 接着为实例变量赋默认值
3. 设置对象的头信息，对象hash码、GC分代年龄、元数据信息等
4. 执行构造函数(init)初始化

### ==OOM的场景和解决方法==

OutOfMemory异常：

1. 堆内存溢出

   堆内存用来存储对象实例，只要不停的创建对象，并且保证GC Roots和对象之间有可达路径避免垃圾回收，那么在对象数量超过最大堆的大小限制后很快就能出现这个异常。

   一般的排查方式可以通过设置-XX: +HeapDumpOnOutOfMemoryError在发生异常时dump出当前的内存转储快照来分析，此外IDEA2018版本之后内置了分析工具，包括Flame Graph(火焰图)和Call Tree(调用树)功能

2. 方法区（运行时常量池）和元空间溢出

   方法区和堆一样，是线程共享的区域，包含class文件信息、运行时常量池、常量池，**运行时常量池**和**常量池**的主要区别是具备动态性，也就是不一定非要是在Class文件中的常量池中的内容才能进入运行时常量池，运行期间也可以可以将新的常量放入池中，比如String的intern()方法。

   1.8之后取消了永久代的概念，转为元空间(Metaspace)

   ```java
   private static String str = "test";
     public static void main(String[] args) {
       List<String> list = new ArrayList<>();
       while (true){
         String str2 = str + str;
         str = str2;
         list.add(str.intern());
       }
   }
   ```

3. 直接内存溢出

   直接内存并不是虚拟机运行时数据区域的一部分，并且不受堆内存的限制，但是受到机器内存大小的限制。常见的比如在NIO中可以使用native函数直接分配堆外内存就容易导致OOM的问题。直接内存大小可以通过-XX:MaxDirectMemorySize指定，**如果不指定，则默认与Java 堆最大值-Xmx一样。**

   由直接内存导致的内存溢出，一个明显的特征是在Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。

4. 栈内存移除

   栈是线程私有，它的生命周期和线程相同。每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息，方法调用的过程就是栈帧入栈和出栈的过程。

   在java虚拟机规范中，对虚拟机栈定义了两种异常：

   1. 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常
   2. 如果虚拟机栈可以动态扩展，并且扩展时无法申请到足够的内存，抛出OutOfMemoryError异常

------



### ==Hashmap原理==

HashMap主要由数组和链表组成，他不是线程安全的。核心的点就是put插入数据的过程，get查询数据以及扩容的方式。JDK1.7和1.8的主要区别在于头插和尾插方式的修改，头插容易导致HashMap链表死循环，并且1.8之后加入红黑树对性能有提升。

> 线程不安全是因为两个线程，有一个在存入，另一个在扩容、复制的时候，对数组的插入不稳定，会导致冲突

**put插入数据流程**

往map插入元素的时候首先通过对key hash然后与数组长度-1进行与运算((n-1)&hash)，都是2的次幂所以等同于取模，但是位运算的效率更高。找到数组中的位置之后，如果数组中没有元素直接存入，反之则判断key是否相同，key相同就覆盖，否则就会插入到链表的尾部，如果链表的长度超过8，则会转换成==红黑树==，最后判断数组长度是否超过默认的长度*负载因子也就是12，超过则进行扩容。

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUljPgPC9h7FmEyOSbttvPehhYJqIVUVqkQmiaXVoachgswvKcUfQ5AdgbJpYngXOvicVTDub1KxYMsw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

**get查询数据**

查询数据相对来说就比较简单了，首先计算出hash值，然后去数组查询，是红黑树就去红黑树查，链表就遍历链表查询就可以了。

**resize扩容过程**

扩容的过程就是对key重新计算hash，然后把数据拷贝到新的数组。

# 深入理解计算机系统

操作系统有两个基本作用：防止硬件被失控的应用程序滥用
					  向应用程序提供简单的机制来控制低级硬件设备
进程是操作系统对正在运行程序的抽象，进程是系统进行资源分配和调度的**基本单位**，在面向线程的计算机结构中，进程是线程的容器，进程是程序的实体
进程由多个称为线程的执行，线程是**独立调度的基本单位**，是操作系统能够进行运算调度的**最小单位**，它被包含在进程之中，是进程中的实际运作单位。

# Java核心技术（一）

## 3.java的基本数据结构

==`&&`==  ==`||`== 都是短路方式求值，一旦第一个表达式确定了他们的值（比如 `1 || x`），那么后面的`x`部分就不进行计算了

但 `&` 和 `|`不是短路的方式

移位运算符的右操作数要完成 mod32，如果左边数为long，则需要 mod64

==**== == 和 equals()区别：在object类中，两者判定的都是地址（是否指向同一个对象），在其他类中，可能equals被改写，改为值的判定，不要用==来判断string是否相等

==空串==和==null==：空串是一个java对象，有自己的长度（0）和内容（空），而String变量可以存放一个特殊的值null，表明目前没有任何对象与该变量关联，就是不存在。 检查既不是空串又不是null时：

```java
if(str!=null && str.length()!=0)
```

StringBuilder的前身时StringBuffer（效率低但允许多线程），如果在单个线程中，则应当用StringBuilder代替StringBuffer

Scanner封装输入，Console封装密码类的输入

```java
Console cons = System.console();
String name = cons.readLine("User name is:");
char[] pwd = cons.readPassword("pwd:");
```

==块== 确定了变量的作用域

==带标签的break==， 可以用来跳出多重循环，也有带标签的continue

```
readData:
{
	{...
		break readData;
	}
}
```

数字数组创建完成后，所有变量都初始化为0，数组大小一旦确定，就**不能再改变**

for each 用来处理数组中的每个元素

```java
int[] a = new int[100];
for(int element : a){}
```

==数组的拷贝==： 如果仅仅是`int[] str1 = str2;`则相当于是引用变量指向同一个数组，

如果需要将数组完整的拷贝到新的数组，`str2 = Array.copyOf(str1，str1.length)；`，后边的长度可以更改，如此可以变相的增加数组的长度

## 4.类和对象

==封装的关键==：在于绝对不能让类中的方法直接访问其他对象的==实例域==（对象中的数据称为实例域），程序仅仅通过方法与对象交互

==构造器==：要使用对象必须要先构造对象，并指定其初始状态 `new Date()` 

对象需要多次使用，就需要存在一个变量中，因此有了==对象变量== `Date birthday`，表明birthday可以引用Date类型的变量，对象变量并没有包含一个实际的对象，仅仅是引用

在一个源文件中，只能有**一个公有类**，但可以有任意数量的非公有类

所有java对象均再堆中构造，且构造器随着new一起使用

`this.`可以将局部变量和实例域（类内的变量）区分开来 

get方法，是典型的访问器方法，只返回实例域的值，被称为域访问器，

==对象克隆==

> 不要编写返回引用**可变对象**的访问器方法，如果访问器返回的实例域是可变的(是个对象，且有更改器方法)，就破坏了程序的封装性，可以使用clone来完成
>
> ```java
> class Employee{
> 	private Date hireDate;
> 	public Date getHireDate(){return hireDate}
> }
> //此时如果有
> Employee harry = ...;
> Date d = harry.getHireDate();
> //那么d.setDate()就能更改harry中hireDate的值，影响封装性
> //通常可以用clone来防止这种问题，如下
> public Date getHireDate(){
>     return (Date) hireDate.clone();
> }
> ```
>
> 如果希望copy一个新对象，初始状态与A相同，但各自会有不同的状态，则可以使用clone()方法
>
> ```java
> //一般的
> Employee original = ...;
> Employee copy = original;
> //则copy和original实际指向一个对象，任何一个变量的更改都可以影响另一个变量
> //如果不想
> Employee copy = original.clone();
> ```
>
> clone是Object的一个protected方法，不能直接调用该方法，但clone是浅拷贝，如果拷贝的对象的实例域(对象的变量)中有引用其他对象，比如`pirvate Date hireDate `，那么拷贝之后的对象和原对象共享子对象 `hireDate`，因此如果要深拷贝，需要重写，如果拷贝的对象实例域没有子对象或者子对象不可变（如String），则没关系

类的方法可以访问该类的**任意对象的私有域！**！！！！

==final==：实例域可以被定义为final，构建对象时必须被初始化，构造器执行之后，这个域的值被设定，且不能再进行更改

==static==:

- 如果定义域为静态域、类域，表明这个类的所有实例共享一个域（变量）
- 静态方法不能访问实例域，只能访问自身类的静态域，不能操作对象，可以理解为静态方法没有this关键字

java允许重载任何方法，通过给定参数类型来匹配相应的方法

调用构造器的步骤：

- 数据域初始化为默认值
- 按照次序执行域初始化语句和初始化块
- 如果构造器第一行调用第二个构造器，则执行
- 执行构造器主体

## 5.继承

==多态== 每个子类的对象也是超类的对象，出现超类对象的任何地方都可以用子类替换。可以将一个子类对象赋值给超类的变量

```java
Employee  e = new Maneger();
```

==方法调用的过程==：

1. 编译器查看对象的声明类型和方法名，列举所有C类种名为f的方法和**超类**中属性为public的方法

   > 调用x.f(args),隐士参数声明为C类的对象，且有多个方法名为f

2. 查看方法的参数类型，完全匹配时，选择（这一过程被称为==重载解析==）

3. 如果为private、static、final方法，则编译器可以直接知道调用哪个方法，这种称为==静态绑定==。当调用方法依赖于隐式参数实际类型时为==动态绑定==，动态绑定开销大

每次调用方法都要搜索的开销很大，因此虚拟机为每个类创建了方法表，列出所有方法签名和实际调用方法，使用时直接查表

方法的名字和参数列表称为==方法的签名==

==final类和方法==：阻止定义子类，不允许拓展，称为final类，final方法不允许子类覆盖这个方法。final域是创建对象之后不允许改变值。当一个方法为final时，方法自动成为final，域不是

# Java高并发程序设计 

## 1.简单概念

==同步==（synchronous）和==异步==（asynchronous）：同步方法调用开始，就必须等到方法调用返回后，才能执行下一步。异步方法则可以调用开始后立即返回（在其他线程中处理任务），调用者可以继续自己的任务

==并发== 和==并行==：都表示多任务同时执行，但并发可以是在同一个线程中的时分复用，但并行则是真正意义上的同时执行

==阻塞==和==非阻塞==：阻塞是指一个线程占据共有资源不释放导致其他等待的线程挂起，非阻塞指没有一个线程可以妨碍其他线程执行

==死锁==、==饥饿==、==活锁==：死锁指多个线程都在等待彼此的资源而造成的永久阻塞，饥饿指优先级低的线程等待资源时一直被高优先级的线程抢占，自己无法拿到资源的情况；活锁指线程都谦让资源给其他线程使用，造成资源在几个线程中来回跳动但没有被执行

并发级别：

- 阻塞：使用synchronized关键字或者重入锁时，得到的就是阻塞线程
- 无饥饿：使用公平锁，不管优先级，遵循先来后到的规则
- ==无障碍==：非阻塞的思想，乐观策略（阻塞是悲观策略），任务线程间不会抢占资源；一旦检测到冲突，则会回滚（增加一致性标记，检查自己在）
- 无锁：无锁的并行都是无障碍的，所有线程都能访问临界区（公共资源、共享数据），在一个无穷循环中，线程不断尝试改变共享变量，直到成功
- 无等待：无锁的更近一步，需要所有的线程在有限步内完成

==原子性==：一个操作不可中断，不受其他线程干扰，（其余基本数据类型、引用变量是原子性，(32位的jvm中)long、double 是非原子性的）

==可见性==：当一个线程修改了共享变量的值的时候，其他变量能立即知道这个修改

==有序性==：在并发时，程序的执行不一定是从前向后的，有可能会出现乱序（程序在执行时，可能出现指令重排），要保证代码的有序性

==指令重排==：汇编指令的顺序执行如果被从称为流水线，在并发时，流水线如果被中断、则会有较大的性能损失， 指令重排就是为了尽量不让流水线中断，避免中断（等待前奏指令执行完之后才能执行剩下步骤的）的缺点



# 深入理解java虚拟机

## 3.垃圾收集器与内存分配策略

程序计数器、本地方法栈、虚拟机栈为线程私有，随着线程创建销毁，不用过多考虑如何回收，方法或线程结束时，内存跟随着回收。

但堆和方法区不同，需要考虑如何进行垃圾回收

判断对象如何存活？

- （教科书中）（java中并不是这样）对象中添引用计数器，引用时加一，引用失效，减一

  但如果两个对象相互循环引用，则计数器都不为0，无法被回收

- ==可达性分析算法==：通过GC root作为起始节点集，根据引用关系向下搜索，搜索过程称为引用链，如果某个对象到GC root没有任何链相连，则不可达，成为可回收对象

  可作为==GC root==的对象：

  - 虚拟机栈（本地变量表中引用对象）
  - 方法区中静态属性和常量引用的对象
  - native方法引用的对象
  - 同步锁持有的对象

  如果对象不可达，也并非一定会死掉，==真正的死亡会经历两次过程==：

  1.如果可达性分析没有发现与GC root相连，则被==第一次标记==，而后进行筛选，筛选条件为该对象是否有必要执行finalize()方法，

  - 如果对象没有覆盖方法或者方法已经被执行，则都视为没有必要执行。
  - 如果被确定为执行`finalize()`方法，则会放入一个F-Queue队列中，并稍后由虚拟机自动建立的一条Finalize线程去执行他们的finalize()方法，finalize()方法时对象逃脱死亡的最后一次机会，

  2.稍后收集器会堆F-Queue中的对象进行==第二次小规模标记==，如果对象在`finalize()`中成功拯救自己（与引用链上的对象关联，比如把自己this关键字赋值给某个类变量或者对象的成员变量），第二次标记时会被移除即将标记的集合，如果还没有逃脱，就会被回收 

  类如何被判定回收？

  1. 类的所有实例都被回收，java堆中不存在任何该类或者派生子类的实例
  2. 加载类的类加载器已经被回收，
  3. 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

#### 3.2垃圾收集算法

##### 分代理论

java堆常被分为新生代和老年代，

新生代中的对象存在时间短、把他们放在一起以较低的代价回收大量的空间，

剩下的难以回收的放在一起，用较低的频率回收这个区域，老年代

新生代中回收后存活的对象放入老年代

如果存在跨代引用（新生代中的东西被年老代引用）（相互引用的两个对象，应当同时存在或者同时消亡），则在新生代中建立全局数据结构——记忆集，把老年代划分为若干小块，标记出年老代中那一块内存会存在跨代引用，当新生代中垃圾收集之后，只有包含了跨代引用的小块内存的对象才会被加入GC root扫描（比起扫描整个老年代划算的多），而后跨代引用的东西加入老年代

##### 标记-清除算法（基本方法）

标记出所有要回收的，然后清除。or 标记存活的对象，然后清除剩余的

缺点：执行效率不稳定，java堆包含大量对象，大部分需要被回收；标记清除后产生大量不连续的内存碎片，导致以后需要分配较大对象时没有连续空间而再次触发垃圾收集动作

##### 标记-复制算法（针对新生代）

新生代中98%熬不过第一轮收集，因此在新生代中建立一个Eden，两个Survivor区域，每次分配内存只是用一块Eden和Survivor，大小比为8：1。垃圾收集后，将Eden和Survivor中存活的复制到另一个Survivor中，然后直接清空Eden和Survivor。

> 但如果存活的超过了Survivor，则有逃生门安全设计，无法容纳时，需要依赖其他内存区域（老年代）进行分配担保

##### 标记-整理算法（老年代）

类似于标记清除算法，只是在标记存活时，将存活的移到内存的一端，而后清理边界外的区域，

##### 和稀泥式回收

先用标记清除，而后碎片化足够严重时使用标记整理算法



class Solution {
    public String predictPartyVictory(String senate) {
        int n = senate.length();
        Queue<Integer> radiant = new LinkedList<Integer>();
        Queue<Integer> dire = new LinkedList<Integer>();
        for (int i = 0; i < n; ++i) {
            if (senate.charAt(i) == 'R') {
                radiant.offer(i);
            } else {
                dire.offer(i);
            }
        }
        while (!radiant.isEmpty() && !dire.isEmpty()) {
            int radiantIndex = radiant.poll(), direIndex = dire.poll();
            if (radiantIndex < direIndex) {
                radiant.offer(radiantIndex + n);
            } else {
                dire.offer(direIndex + n);
            }
        }
        return !radiant.isEmpty() ? "Radiant" : "Dire";
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/dota2-senate/solution/dota2-can-yi-yuan-by-leetcode-solution-jb7l/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

# labuladong的算法小抄

> https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/xue-xi-shu-ju-jie-gou-he-suan-fa-de-gao-xiao-fang-fa

## 零

### 1.数据结构的存储方式

**数据的存数组储方式只有两种，数组和链表**

> 其他的诸如散列表、栈、堆等都是对数组和链表的特殊操作

优缺点：

**数组**由于是紧凑连续存储,可以==随机访问==，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。

**链表**因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的==扩容==问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。

### 2.数据结构的基本操作

基本操作就是增删查改

对于数组来说，迭代即可

但对于链表来说，可以迭代和递归

```java
//单链表
class ListNode{
	int val;
    ListNode next;
}

void traverse(ListNode head){
    for(ListNode p = head; p != null; p = p.next){
        //迭代访问p.val 
    }
}

void traverse(ListNode head){
    //递归访问head.val
    traverse(head.next)
}
```

二叉树遍历框架，典型的非线性递归遍历结构

```java
//基本的二叉树结点
class TreeNode{ 
    int val;
    TreeNode left,right;
}

void traverse(TreeNode root){
    traverse(TreeNode.left);
    traverse(TreeNode.right);

}
```

 