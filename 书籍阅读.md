# 深入理解计算机系统

操作系统有两个基本作用：防止硬件被失控的应用程序滥用
					  向应用程序提供简单的机制来控制低级硬件设备
进程是操作系统对正在运行程序的抽象
进程由多个称为线程的执行



为什么数据库索引中需要用B树or B+树？

> 因为数据库存储的数据和索引都放在磁盘，他们以页为单位管理磁盘，AVL或红黑树搜索效率尽管高，但是同样的数据项，他们的树要比B B+树高，高意味着平均来说访问更多的节点，即磁盘IO次数，表面上B、B+没有二叉搜索树效率高，但是实际上因为树高度低，减少IO次数，所以速度快

AVL树：左右子树高度差不超过1



# 深入理解java虚拟机

## 3.垃圾收集器与内存分配策略

程序计数器、本地方法栈、虚拟机栈为线程私有，随着线程创建销毁，不用过多考虑如何回收，方法或线程结束时，内存跟随着回收。

但堆和方法区不同，需要考虑如何进行垃圾回收

判断对象如何存活？

- （教科书中）（java中并不是这样）对象中添引用计数器，引用时加一，引用失效，减一

  但如果两个对象相互循环引用，则计数器都不为0，无法被回收

- ==可达性分析算法==：通过GC root作为起始节点集，根据引用关系向下搜索，搜索过程称为引用链，如果某个对象到GC root没有任何链相连，则不可达，成为可回收对象

  可作为GCroot的对象：

  - 虚拟机栈（本地变量表中引用对象）
  - 方法区中静态属性和常量引用的对象
  - native方法引用的对象
  - 同步锁持有的对象

  如果对象不可达，也并非一定会死掉，==真正的死亡会经历两次过程==：

  1.如果可达性分析没有发现与GC root相连，则被==第一次标记==，而后进行筛选，筛选条件为该对象是否有必要执行finalize()方法，

  - 如果对象没有覆盖方法或者方法已经被执行，则都视为没有必要执行。
  - 如果被确定为执行`finalize()`方法，则会放入一个F-Queue队列中，并稍后由虚拟机自动建立的一条Finalize线程去执行他们的finalize()方法，finalize()方法时对象逃脱死亡的最后一次机会，

  2.稍后收集器会堆F-Queue中的对象进行==第二次小规模标记==，如果对象在`finalize()`中成功拯救自己（与引用链上的对象关联，比如把自己this关键字赋值给某个类变量或者对象的成员变量），第二次标记时会被移除即将标记的集合，如果还没有逃脱，就会被回收 

  类如何被判定回收？

  1. 类的所有实例都被回收，java堆中不存在任何该类或者派生子类的实例
  2. 加载类的类加载器已经被回收，
  3. 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

#### 3.2垃圾收集算法

##### 分代理论

java堆常被分为新生代和老年代，

新生代中的对象存在时间短、把他们放在一起以较低的代价回收大量的空间，

剩下的难以回收的放在一起，用较低的频率回收这个区域，老年代

新生代中回收后存活的对象放入老年代

如果存在跨代引用（新生代中的东西被年老代引用）（相互引用的两个对象，应当同时存在或者同时消亡），则在新生代中建立全局数据结构——记忆集，把老年代划分为若干小块，标记出年老代中那一块内存会存在跨代引用，当新生代中垃圾收集之后，只有包含了跨代引用的小块内存的对象才会被加入GC root扫描（比起扫描整个老年代划算的多），而后跨代引用的东西加入老年代

##### 标记-清除算法（基本方法）

标记出所有要回收的，然后清除。or 标记存活的对象，然后清除剩余的

缺点：执行效率不稳定，java堆包含大量对象，大部分需要被回收；标记清除后产生大量不连续的内存碎片，导致以后需要分配较大对象时没有连续空间而再次触发垃圾收集动作

##### 标记-复制算法（针对新生代）

新生代中98%熬不过第一轮收集，因此在新生代中建立一个Eden，两个Survivor区域，每次分配内存只是用一块Eden和Survivor，大小比为8：1。垃圾收集后，将Eden和Survivor中存活的复制到另一个Survivor中，然后直接清空Eden和Survivor。

> 但如果存活的超过了Survivor，则有逃生门安全设计，无法容纳时，需要依赖其他内存区域（老年代）进行分配担保

##### 标记-整理算法（老年代）

类似于标记清除算法，只是在标记存活时，将存活的移到内存的一端，而后清理边界外的区域，

# labuladong的算法小抄

> https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/xue-xi-shu-ju-jie-gou-he-suan-fa-de-gao-xiao-fang-fa

## 零

### 1.数据结构的存储方式

**数据的存数组储方式只有两种，数组和链表**

> 其他的诸如散列表、栈、堆等都是对数组和链表的特殊操作

优缺点：

**数组**由于是紧凑连续存储,可以==随机访问==，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。

**链表**因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的==扩容==问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。

### 2.数据结构的基本操作

基本操作就是增删查改

对于数组来说，迭代即可

但对于链表来说，可以迭代和递归

```java
//单链表
class ListNode{
	int val;
    ListNode next;
}

void traverse(ListNode head){
    for(ListNode p = head; p != null; p = p.next){
        //迭代访问p.val 
    }
}

void traverse(ListNode head){
    //递归访问head.val
    traverse(head.next)
}
```

二叉树遍历框架，典型的非线性递归遍历结构

```java
//基本的二叉树结点
class TreeNode{ 
    int val;
    TreeNode left,right;
}

void traverse(TreeNode root){
    traverse(TreeNode.left);
    traverse(TreeNode.right);

}
```

 