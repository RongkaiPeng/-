## 附录：

==对象==：一个自包含的实体，用一组可识别的特征和行为来标识

==类==：具有相同的属性和功能的=**对象**的集合

>  类名称首字母大写，变量使用驼峰规则

对象是类的实例，类是对象的模板

==实例==：就是一个真实的对象，是类的实例，实例化就是创建对象的过程，使用 new 来创建

==构造方法==：又叫构造函数，就是对类进行初始化，构造方法与类同名，没有返回值，不需要void，在new的时候调用，在Cat cat = new Cat() 时，new 后面的()就是构造方法

> 所有的类都有构造方法，如果你不写则用系统默认生成空的构造方法，若你定义，则使用你定义的构造方法
>
> ```java
> class Cat{
> 	private string name = "";
>     public Cat(string name){
> 		this.name = name;
> 	}
> 
> 	public string shout(){
> 		return "miao";
> 	}
> }
> //此时，Cat cat = new Cat("咪咪")就是给实例起了个名字
> ```

==方法重载==：如果上述代码中执行Cat cat = new Cat() 则就会报错，此时必须给Cat一个参数，如果我们不想传参数，就可以使用方法的重载，方法的重载提供了创建同名的多个方法的能力，但这些方法需要使用不同的参数类型

> ```java
> class Cat{
> 	private string name = "";
>     public Cat(string name){
> 		this.name = name;
> 	}
> 	public Cat(){
> 		this.name = "无名";
> 	}
> 	public string shout(){
> 		return "名字是"name+"miao";
> 	}
> }
> ```
>
> 方法重载时，两个方法必须方法名相同，但参数类型或者个数必须不同，比如上述代码中，可以为 Cat(string name, string first name) 或者 Cat(int age) 这种，都是方法的重载

方法的重载可以在不改变原方法的基础上新增功能，增强了函数的可拓展功能

==属性==：（变量的公有化？）是一个方法或者方法对，但在调用它的代码来看，他是一个字段（私有变量），即属性适合于以字段的方式使用方法调用的场合（比如下图代码块的ShoutNum）

==字段==：是存储类要满足其设计所需要的数据，字段是与类相关的变量，比如上述代码中的变量name就是一个字段，它通常是**私有的**类变量

**私有变量叫字段，公有变量叫属性**

==public==:所修饰的类成员可以允许其他类访问，公有

==private==：只允许同一个类中的成员访问，其他类包括他的子类无法访问，私有的。

> 如果类中的成员没加修饰符，则被认为是private
>
> 通常字段（变量）都是私有，方法公有

属性的两个方法 ==get== 和 ==set== ：get访问器返回与声明的属性相同的数据，意思是调用时可以得到内部字段值或引用；set访问器没有显式设置参数，但他有一个隐式参数，用value表示，作用是调用属性时可以给内部的字段或引用赋值

一般在java中使用**set/get+变量名**来实现对应的功能，设置/获得对应的参数值

> ```java
> private int shoutNum = 3;
> public int ShoutNum{		//对外用的变量就是ShoutNum
> 	get{    				//表示外部调用时可以得到shouNum的值
> 		return shoutNum;
> 	}
> 	set{					//表示外界可以给shoutNum赋值
> 		return value;
> 	}
> }
> ```
>
> 可以通过public方法来修改内部的私有值，或者查看内部的私有值
>
> 其真实的使用方法为：这样就可以从外部传值
>
> ```java
> class Cat{
>     private int shoutNum = 3;
>     public int getshoutNum(){
>         return shoutNum;
>     }
>     public void setshoutNum(int shoutNum){
>         this.shoutNum = shoutNum;
>     }
> }
> ```
>
> 

==封装==：每个对象都包含他能进行操作所需要的所有信息，这个特性称为封装，因此对象不用依赖于其他对象来完成自己的操作，==封装的优点==有：

- 良好的封装减少耦合
- 类内部的实现可以自由的修改
- 类具有清晰的对外接口

==继承==：在继承关系中，子类拥有父类非Private的属性和功能，子类可以扩展父类没有的属性和功能，也可以以自己的方式实现父类的功能，其中==protected==修饰的类成员，对子类公开，但对其他类不公开

子类从父类中继承的成员有方法、域、属性、事件、索引指示器、但**构造方法不能被继承，只能被调用**，对于调用父类的成员，可以使用base 关键字

> ```java
> class Cat : Animal {//继承Animal类
>     
> ```

==继承的缺点==：父类改变的时候，子类必须改变；继承会破坏包装，父类的实现细节暴露给子类，其实是增大了两个类之间的耦合性(藕断丝连的特性？)，继承是一中强耦合的关系

==多态==：表示不同的对象可以执行相同的操作，，但要通过他们自己的代码来执行

- 子类以父类的身份出现
- 子类在工作时以自己的方式实现
- 子类以父类的身份出现时，子类特有的属性和方法不可以实现

实例化的对象是子类，才能实现多态。多态的原理是当方法被调用时，无论对象是否被转换为其父类，都只有位于对象继承链最末端的方法实现会被调用，虚方法时按照其运行时类型而非编译时类型进行动态绑定调用的

==虚方法==：为了使子类的实例完全接替来自父类的类成员，父类必须将该成员声明为虚拟的，通过在返回值类型前添加 **virtual** 来实现

> ```java
> public virtual string shout(){ return "" }		//加入virtual，表示此方法虚拟，可以被子类重写
> ```
>
> 通常虚拟的是方法，除了字段不能被虚拟，属性、事件和索引器都可以虚拟

==重写==：而子类可以通过override 关键字来重写方法，将父类替换为它自己的实现

> ```java
> pubilc override string shout(){ ...}		//表示该方法重写
> ```

==抽象类==：实例化没有任何意义的类，比如上述代码中的 Animal 类，所以可以把它改造成抽象类，声明为abstract

> ```java
> abstract class Animal{}
> ```

- 抽象类不能被实例化
- 抽象方法必须被子类重写，抽象方法是没有实现体的虚方法
- 如果类中包含抽象方法，那么类就必须被定义为抽象类，不论是否还包含其他一般方法
- 抽象类应该拥有尽可能多的代码、尽可能少的数据
- 抽象类是继承的一个出发点，他就是用来继承的 

==接口==：把隐式的公共方法和属性组合起来，以封装成特定功能的一个集合，一旦类实现了接口，类就可以支持接口所指定的属性和成员。接口的声明和抽象类完全相同，但不允许提供任何成员的执行方式，所以

接口不能实例化，不能有修饰符，不能用声明虚拟或静态，实现接口的类必须要实现接口中的所有方法和属性

接口用interface声明，但接口名称前必须加大写的  I  

>```java
>interface IChange{
>	string changeThing(string thing);
>}
>```
>
>```java
>class MachineCat : Cat,IChange{		//继承于猫，并实现IChange接口
>    public MachineCat():base(){}
>    public string changThing(string thing){
>        return base.Shout()+""+thing;
>    }
>}
>```

==抽象类和接口的区别==：抽象类可以给出一些成员的实现，接口却不包含成员的实现，抽象类的抽象成员可被子类部分实现，接口的成员需要实现类完全实现，一个类只能继承一个抽象类，但可实现多个接口

- 抽象类是对类的抽象，类是对象的抽象，接口是方法的抽象（如果只关注行为，那么也可以认为接口就是抽象类）

- 如果行为跨越不同类的对象，可使用接口，对于一些相似的类对象，用抽象类

  比如 超人属于人，人是抽象类，超人是具体实现，但超人能飞，人不能，飞机也能飞，这时超人和飞机就能共用飞这个接口

- 抽象类是从子类中发现了公共的东西，泛化出父类，然后子类继承父类，而接口不知道子类的存在，方法如何实现还不确定，只是预先定义

 ==泛型==：使用泛型集和，这样可以获得类型安全的直接优点而不需要从基集和类型派生并实现类型特定的成员

 		如果集合元素为值类型，泛型集和类型通常优于对应的非泛型集和类型

​		使用泛型是不用对元素装箱

==委托与事件==：用`delegate`和`event`声明